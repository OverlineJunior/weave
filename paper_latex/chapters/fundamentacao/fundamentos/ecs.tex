% NOTA: O código abaixo requer o uso de pacotes como 'graphicx', 'listings' e um
% pacote de bibliografia como 'biblatex' ou 'natbib' para funcionar corretamente.
% A função personalizada 'figura_legendada' foi traduzida para um ambiente 'figure' padrão.
% Ajustes podem ser necessários para corresponder exatamente à sua formatação original.

\subsection{Entity Component System}

Entity Component System (ECS) é um padrão arquitetural baseado no design orientado a dados. Ele surgiu na área de desenvolvimento de jogos, onde há uma grande necessidade de otimização e atualizações frequentes no código. Com o passar do tempo, o padrão ECS começou a ser utilizado em outras áreas, como em simulações físicas \cite{flightdynamics}.

O padrão consiste na separação de dado e lógica de tal forma que as vários entidades da aplicação possam ser compostas de dados reutilizáveis e independentes \cite{ecsfaq}, com as funções sendo direcionadas aos dados, e não às entidades em si. Devido ao desacoplamento gerado por essa separação, o padrão ECS garante alta flexibilidade e modularidade, além do aumento de desempenho gerado pela melhor distribuição de dados na memória \cite{ecsstorageinpics}.

Neste projeto, o padrão ECS será um dos principais fundamentos para o design e implementação da linguagem de programação, já que o intuíto dela será abstrair ele.

\subsubsection{Os Três Elementos Fundamentais do ECS}

Com base na explicação de \textcite{ecsfaq}, pode-se dizer que o ECS é separado em três elementos fundamentais: entidades, componentes e sistemas. Cada um desses elementos desempenha um papel específico na aplicação:

\begin{itemize}
    \item Entidades: identificadores únicos que representam os vários conceitos de uma aplicação. Sozinhas, as entidades não contêm dados nem funcionalidade;
    \item Componentes: estruturas de dados que armazenam informações específicas. Uma entidade pode ter múltiplos componentes diferentes, definindo suas características;
    \item Sistemas: funções responsáveis por processar sobre entidades com um determinado conjunto de componentes — processo denominado querying.
\end{itemize}

Como ilustrado na \autoref{fig:diagrama_ecs}, o estado da aplicação é dado por um conjunto de entidades, cada uma com seus respectivos componentes. Os sistemas são responsáveis pela transformação do estado da aplicação, processando as entidades que possuem os componentes necessários para a execução do sistema.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.35\textheight]{diagrama_ecs}
	\caption{Relação entre entidades, componentes e sistemas.}
	\fonte{Elaboração própria.}
	\label{fig:diagrama_ecs}
\end{figure}

Em termos de código, o padrão ECS pode ser representado sem nenhum construto especializado, mapeando entidades para números únicos, componentes para \textit{structs} e sistemas para funções:

% % A função 'figura_legendada' com um bloco de código foi traduzida abaixo.
% % NOTA: O código abaixo requer o pacote 'listings'.
% % Adicione \usepackage{listings} e configure-o no seu preâmbulo.
% \begin{figure}[h!]
%     \centering
%     \begin{lstlisting}[language=Rust, basicstyle=\small\ttfamily]
%     // Componentes podem ser representados através de simples structs.
%     struct Position { x: f32, y: f32 }

%     struct Velocity { dx: f32, dy: f32 }

%     // Sistemas podem ser representados como funções que processam todas as
%     // entidades e seus respectivos componentes.
%     fn apply_velocity(
%         entities: &[usize],
%         positions: &mut [Position],
%         velocities: &[Velocity]
%     ) {
%         for &entity in entities {
%             positions[entity].x += velocities[entity].dx;
%             positions[entity].y += velocities[entity].dy;
%         }
%     }

%     fn main() {
%         // Entidades podem ser representadas como números únicos.
%         let entities = [0, 1];

%         // Cada componente é armazenado em um vetor separado, onde o índice
%         // representa a entidade e o valor representa seu componente.
%         let mut positions = [
%             Position { x: 0.0, y: 0.0 }, // Entidade 0.
%             Position { x: 1.0, y: 1.0 }, // Entidade 1.
%         ];

%         let velocities = [
%             Velocity { dx: 1.0, dy: 1.0 }, // Entidade 0.
%             Velocity { dx: 2.0, dy: 2.0 }, // Entidade 1.
%         ];

%         // No padrão ECS, é muito comum que os sistemas sejam executados repetidamente.
%         loop {
%             apply_velocity(&entities, &mut positions, &velocities);
%         }
%     }
%     \end{lstlisting}
%     \caption{Implementação simplificada de um padrão ECS incompleto.}
%     \label{fig:ecs_simplificado}
%     \footnotesize{\textit{Fonte: elaboração própria.}}
% \end{figure}

% É importante ressaltar que o código acima, por mais que seja funcional e siga o design orientado a dados, ainda é uma simplificação da implementação de um padrão ECS incompleto. Na prática, o armazenamento dos dados é feito através de estruturas de dados mais complexas \cite{ecsstorageinpics}, que permitem que entidades escolham quais componentes possuem, que sistemas sejam executados automaticamente, além de outras funcionalidades principais do padrão ECS.

% Fora a definição de ECS e seus três elementos fundamentais, o padrão ainda peca pela falta de formalização — quais são as práticas recomendadas ao usar ECS? Como os sistemas são executados? E se apenas entidades, componentes e sistemas não forem suficientes para resolver meu problema? Essas perguntas não possuem respostas definitivas, porém, diferentes autores e implementações abordam o padrão do seu jeito. A seguir, são apresentados alguns conceitos herdados de tais autores e implementações.

% \subsubsection{Agendador}

% O agendador é um construto com a finalidade de executar todos os sistemas da aplicação, podendo determinar a ordem e frequência de execução de forma declarativa, resolvendo dependência entre sistemas e tornando o ciclo de atualização da aplicação mais previsível \cite{bevy}. Pode-se dizer que, dentre os conceitos mais experimentais, o agendador é o mais próximo de uma formalização.

% \begin{figure}[h!]
%     \centering
%     \includegraphics[height=0.30\textheight]{../../../../images/diagrama_agendador.png}
%     \caption{Agendador executando os sistemas de forma cíclica e sequencial.}
%     \label{fig:diagrama_agendador}
%     \footnotesize{\textit{Fonte: elaboração própria.}}
% \end{figure}

% \subsubsection{Relacionamento de Entidades}

% Independente da aplicação, é muito comum a necessidade de relacionar diferentes conceitos entre si. Exemplo disso são os sistemas de arquivos, onde pastas podem conter arquivos, uma relação pai-filho.

% Relacionamento de entidades (do inglês, \textit{entity relationship}) é um conceito que supre essa necessidade, permitindo que entidades se relacionem entre si. O autor da biblioteca Flecs,
% % NOTA: O comando #cite(..., form: "author") foi traduzido para \citeauthor{...}.
% % Isso geralmente requer o pacote 'biblatex'.
% \citeauthor{flecs}, explica o conceito fazendo uma paralela com o simples ato de adicionar um componente a uma entidade:

% \begin{figure}[h!]
%     \centering
%     % A 'figura_legendada' aqui continha tanto imagem quanto um pequeno trecho de código.
%     % Eles foram colocados um após o outro.
%     \includegraphics[height=0.06\textheight]{../../../../images/entidade_posicao.png}
%     \begin{lstlisting}[language=TypeScript, basicstyle=\small\ttfamily]
% Entidade.set<Posição>({0, 0});
%     \end{lstlisting}
%     \caption{Entidade com um componente de posição.}
%     \label{fig:entidade_posicao}
%     \footnotesize{\textit{Fonte: \textcite{entityrelationships}.}}
% \end{figure}

% Do mesmo jeito que se adiciona um único componente a uma entidade, como mostra a figura acima, pode-se criar um relacionamento entre duas entidades adicionando uma tupla componente-entidade, onde o componente dita o tipo de relação:

% \begin{figure}[h!]
%     \centering
%     \includegraphics[height=0.13\textheight]{../../../../images/relacionamento_entidades.png}
%     \begin{lstlisting}[language=CSharp, basicstyle=\small\ttfamily]
% Terra.add(FilhoDe, Sol);
% Lua.add(FilhoDe, Terra);
%     \end{lstlisting}
%     \caption{Representação do relacionamento entre o Sol, a Terra e a Lua.}
%     \label{fig:relacionamento_sol_terra_lua}
%     \footnotesize{\textit{Fonte: adaptado de \textcite{entityrelationships}.}}
% \end{figure}

% \subsubsection{Depurador de ECS}

% Um depurador especializado em ECS é uma interface, gráfica ou não, responsável por ajudar o desenvolvedor a encontrar e resolver bugs relacionados ao ECS na aplicação. Tal depurador pode visualizar todas as entidades da aplicação, além  de seus respectivos componentes. Ele também pode listar os sistemas em execução e permitir o controle sobre eles, como pausar ou alterar a ordem de execução.

% \begin{figure}[h!]
%     \centering
%     \includegraphics[height=0.30\textheight]{../../../../images/flecs_explorer.png}
%     \caption{Flex Explorer, depurador visual para a biblioteca Flecs.}
%     \label{fig:flecs_explorer}
%     \footnotesize{\textit{Fonte: \textcite{flecsexplorer}.}}
% \end{figure}
