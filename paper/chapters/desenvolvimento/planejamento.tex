\section{Planejamento}

Antes de iniciar o desenvolvimento do protótipo, foi realizado um planejamento com a finalidade de responder às questões de quais ferramentas utilizar, como a linguagem se pareceria, como seriam organizadas as diferentes partes do código, entre outras.

Usando como base as definições da seção \ref{sec:design_linguagem}, a linguagem proposta foi uma linguagem de programação imperativa com tipagem dinâmica, facilidando a implementação do interpretador, já que não é necessário a im
plementação de um sistema de tipos complexo.

A sintaxe foi inspirada na família de linguagens C, evidenciado pelo uso de chaves para delimitar blocos de código e instanciar componentes, ilustrado no \autoref{cod:goal_syntax}. A escolha se deve à familiaridade da sintaxe, que facilita a adoção da linguagem. Já a semântica foi inspirada na biblioteca de ECS Flecs e seu tratamento de componentes e sistemas como entidades \cite{flecs}. A escolha se deve ao potencial de flexibilidade e ortogonalidade que essa abordagem oferece, que será demonstrado pelas sugestões de pesquisas futuras.

Para a implementação do interpretador, foi escolhida a linguagem Rust. A escolha se deve principalmente pelo seu sistema de tipos, cuja utilidade será explorada na implementação do interpretador. Dentro do ecossistema Rust, a biblioteca Chumsky foi escolhida para a implementação do \textit{parser} devido a sua maturidade, facilitando a implementação em comparação com \textit{parsers} escritos do zero.

Por fim, foi criado um exemplo de código na linguagem proposta, contendo a sintaxe completa da linguagem. Ter um exemplo concreto ajudou a guiar o desenvolvimento do interpretador, servindo como um objetivo a ser alcançado. O exemplo completo pode ser visto no \autoref{cod:goal_syntax}.

\codigoRust
\lstinputlisting[
	language=Rust,
	label=cod:goal_syntax,
	caption={Exemplo de código na linguagem proposta, demonstrando de forma exaustiva sua sintaxe.}
]{../codes/goal_syntax.rs}
\vspace{-1em}
\fonte{Elaboração própria.}

O \autoref{cod:goal_syntax} consiste na definição de componentes para representar pessoas, rochas e nomes, além da criação de entidades com esses componentes e um sistema que apenas imprime o nome de pessoas, excluindo as rochas. Vale ressaltar que o código representa toda a sintaxe da linguagem, o que significa que o que não está presente não faz parte da linguagem, como reatribuição de campos e operações aritméticas. Tal falta de recursos é intencional, já que o objetivo do protótipo é explorar a viabilidade da implementação de uma linguagem com recursos de ECS em específico, e não uma linguagem tradicional.

Com a linguagem e ferramentas definidas, além do exemplo concreto de código para guiar o desenvolvimento, o planejamento foi concluído a implementação do interpretador pode ser iniciada.
