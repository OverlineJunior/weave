\chapter{Conclusão} \label{ch:conclusao}

Este trabalho projetou e implementou de forma parcial um protótipo de interpretador para uma linguagem orientada ao padrão \textit{Entity Component System}, cumprindo a maioria dos objetivos inicialmente propostos, salvo a implementação completa da fase de interpretação.

O escopo incluiu a implementação das fases de análise léxica e sintática, além da formalização da fase de interpretação e do registro de escolhas de técnicas e bibliotecas utilizadas ao longo do desenvolvimento. Com o protótipo parcialmente funcional e a documentação de decisões tomadas completa, foi possível avaliar a viabilidade do trabalho, identificando tanto os pontos fortes quanto as limitações encontradas.

\section{Principais Resultados e Contribuições}

Como analisado no capítulo \ref{ch:analise_resultados}, o protótipo de interpretador conseguiu transformar o código fonte em uma AST completa, e identificado que sua implementação se assemelha muito com a implementação do interpretador Jlox, salvo a fase de interpretação, que é onde há a ponte entre o interpretador e a biblioteca de ECS.

A contribuição mais significativa deste trabalho é a implementação do protótipo de interpretador, que, atendendo a maioria dos objetivos propostos, serve como base para trabalhos futuros. Isso se deve pelo fato de que, assim como comentado na seção \ref{sec:justificativa}, a proposta deste trabalho não só é incomum, como também peca por não haver artigos e documentação sobre o assunto, tornando trabalhos futuros mais difíceis de serem feitos.

\section{Viabilidade e Limitações}

Assim como discutido na seção \ref{sec:viabilidade_limitacoes}, a implementação do protótipo de interpretador se mostrou viável quanto as fases de análise léxica e sintática. Porém, a implementação da fase de interpretação se mostrou inviável dentro do tempo disponível devido à dificuldade de representar tipos dinâmicos em
Rust e à falta de documentação sobre componentes dinâmicos na biblioteca de ECS escolhida.

Além disso, também na seção \ref{sec:viabilidade_limitacoes}, foi visto que o protótipo possui outras limitações, como a falta de recursos proporcionados pela linguagem e a ausência de considerações quanto a desempenho. Por mais que intencionais, essas limitações restringem o uso do protótipo a fins educacionais e de pesquisa, não sendo adequado para aplicações práticas.

\section{Sugestões para Trabalhos Futuros}

% TODO!
% Sabendo que o escopo deste trabalho foi propositalmente limitado, e que o objetivo era fornecer uma base para trabalhos futuros, há uma ênfase em sugestões para trabalhos futuros. A seguir, são listadas algumas sugestões, onde as três primeiras buscam resolver as limitações do protótipo, enquanto as duas últimas tomam liberdade criativa para sugerir novos recursos:

% \subsection{Explorar Otimizações e Analisar o Desempenho}

% \subsection{Dar Suporte a \textit{Queries} Mais Complexas}

% \subsection{Implementar um Agendador de Sistemas}

% \subsection{Explorar a Organização de Sistemas e Componentes}

% \subsection{Explorar o Conceito de Componentes e Sistemas como Entidades}

Sabendo que o escopo deste trabalho foi propositalmente limitado, e que o objetivo era fornecer uma base para trabalhos futuros, há uma ênfase em sugestões para trabalhos futuros. As sugestões mais relevantes são listadas a seguir:

\subsection{Devidamente Implementar a Fase de Interpretação}

A sugestão mais óbvia é implementar a fase de interpretação que não pôde ser integrada ao interpretador devido a restrições de tempo. Com isso, o protótipo se tornaria funcional por completo, permitindo que programas escritos na linguagem proposta sejam efetivamente interpretados.

\subsection{Explorar Otimizações e Analisar o Desempenho}

Explorar otimizações relacionadas a um interpretador orientado ao padrão ECS, também fazendo análises de desempenho. Isso se deve ao fato de que desempenho foi a motivação inicial por trás do ECS, e é muito provável que um interpretador como o deste trabalho possa se beneficiar de otimizações específicas relacionadas ao padrão.

Adicionalmente, muitos dos artigos autorados por Sander Mertens, autor muito citado neste trabalho, discutem otimizações relacionadas ao ECS, como a aplicação do \textit{design} orientado a dados ao ECS e a organização interna de entidades e componentes \cite{ecsfaq, ecsstorageinpics}. Esses artigos podem servir de base para trabalhos futuros que busquem explorar otimizações dentro do contexto deste trabalho.

\subsection{Dar Suporte a \textit{Queries} Mais Complexas}

O sistema de \textit{queries} implementado no protótipo é extremamente simples, suportando apenas a seleção de entidades que possuem todos os componentes listados. Sistemas de \textit{queries} mais complexos podem ser implementados na linguagem proposta, permitindo que o usuário seja mais expressivo ao definir quais entidades um sistema deve processar.

Baseado na documentação das bibliotecas de ECS Flecs e Bevy, será listado a seguir alguns exemplos de recursos que podem ser implementados em um sistema de \textit{queries} mais complexo:

\begin{itemize}
    \item \textbf{Exclusão de Componentes}: Permitir que o usuário especifique componentes que uma entidade não deve possuir para ser selecionada por um sistema \cite{flecs, bevy};
    \item \textbf{Componentes Opcionais}: Permitir que o usuário especifique componentes que uma entidade pode ou não possuir para ser selecionada por um sistema \cite{flecs, bevy};
    \item \textbf{Relacionamentos entre Entidades}: Permitir que o usuário especifique relacionamentos entre entidades para serem selecionadas por um sistema, já que atualmente, este conceito só é aplicado internamente pelo interpretador \cite{flecs, bevy};
    \item \textbf{Múltiplas Entidades em uma Única \textit{Query}}: Permitir que o usuário selecione componentes de múltiplas entidades em uma única \textit{query}, possibilitando que um sistema atue sobre os dados de mais de uma entidade por vez. Este tópico é discutido de forma aprofundada no artigo \textit{Why it is time to start thinking of games as databases} de \citeonline{ecsstorageinpics}.
\end{itemize}

\subsection{Explorar o Conceito de Componentes e Sistemas como Entidades}

Uma sugestão que talvez possa fazer a ideia de um interpretador orientado ao padrão ECS valer mais a pena é explorar como o conceito de componentes e sistemas tratados como entidades pode ser aplicado na linguagem proposta.

Com este conceito aplicado, seria possível atribuir metadados a componentes e sistemas, além de poder criar sistemas que operam sobre outros sistemas ou componentes, permitindo vários tipos de abstrações diferentes sem a necessidade de novas alterações na linguagem, caracterizando assim uma linguagem altamente ortogonal.

A seguir são listadas duas ideias de como esse conceito pode ser aplicado na linguagem proposta:

\begin{itemize}
    \item \textbf{Modificadores de Componentes}: Permitir que o usuário atribua metadados que alteram o comportamento de componentes\footnote{Este conceito já é utilizado na biblioteca Flecs, lá chamados de \textit{Traits} \cite{flecs}.}, como tornar um componente mutualmente exclusivo com outro;
    \item \textbf{Agendamento de Sistemas}: Permitir que o usuário defina a ordem de execução de um sistema logo ao lado de sua declaração, ou até mesmo criar sistemas que alteram a ordem de execução de outros sistemas.
\end{itemize}

Vale notar que, apesar dessas sugestões também poderem ser implementadas em uma biblioteca de ECS tradicional, uma linguagem pode torná-las mais acessíveis e expressivas através de sua sintaxe. O código \autoref{cod:exemplo_futuro} demonstra um exemplo de sintaxe que poderia ser usada para implementar essas duas ideias.

\codigoRust
\lstinputlisting[
    language=Rust,
    label=cod:exemplo_futuro,
    caption=Exemplo de sintaxe para implementar modificadores de componentes e agendamento de sistemas utilizando o conceito de componentes e sistemas como entidades.
]{../codes/exemplo_futuro.rs}
\vspace{-1em}
\fonte{Elaboração própria.}

No código \autoref{cod:exemplo_futuro}, nota-se a sintaxe que faz uso dos caracteres \texttt{@}, \texttt{(} e \texttt{)}. O caractere \texttt{@} indica uma inserção de componente em tempo de compilação, enquanto os caracteres \texttt{(} e \texttt{)} indicam um relacionamento entre entidades. Com ambos, é possível implementar tanto as ideias sugeridas quanto muitos outros conceitos que possam reutilizar a mesma sintaxe.

\section{Considerações Finais}

Com o protótipo funcional e documentado, foi possível alcançar os objetivos propostos, além de avaliar a viabilidade do trabalho e sugerir trabalhos futuros, tornando este trabalho uma base para pesquisas futuras na área de linguagens de programação orientadas ao padrão \textit{Entity Component System}.
